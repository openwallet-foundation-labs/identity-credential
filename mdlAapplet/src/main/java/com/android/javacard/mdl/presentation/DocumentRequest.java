/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.javacard.mdl.presentation;

import com.android.javacard.mdl.CBORBase;
import com.android.javacard.mdl.CBORDecoder;
import com.android.javacard.mdl.CBOREncoder;
import com.android.javacard.mdl.MdlSpecifications;
import com.android.javacard.mdl.SEProvider;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacard.framework.JCSystem;
import javacard.framework.Util;
import javacard.security.ECPrivateKey;
import javacard.security.HMACKey;
import javacard.security.KeyAgreement;
import javacard.security.KeyBuilder;
import javacard.security.Signature;

/**
 * This class handles the DocumentRequest processing. For each document request it enumerates the
 * data by selecting it from PresentationPkg. Thus, Document Request is like a select command where
 * as PresentationPkg is like a table. Each document Request stores the start and end of element
 * values for all the data items requested in the document request. It also generates device
 * signature for the response.
 */
public class DocumentRequest {

  // Namespace Entry consists of {Name Space Id amd offset in Element Array and elem count}
  private static final short NS_ARR_ENTRY_SIZE = 3;

  // Element Array consists of element entry index in element table in presentation pkg.
  private static final short ELEM_ARR_ENTRY_SIZE = 1;

  // TODO change the following if there are more namespaces and/or elements per namespaces per
  // request.
  // Max 64 elements per namespace for 8 namespaces
  private static final short MAX_ELEMENT_TABLE_SIZE = (short) (ELEM_ARR_ENTRY_SIZE * 512);
  private static final short MAX_NS_TABLE_SIZE = (short) (NS_ARR_ENTRY_SIZE * 8);

  private static final short NS_KEY_ID_OFFSET = 0;
  private static final short NS_ELEMENT_TABLE_INDEX = 1;
  private static final short NS_ELEMENT_COUNT = 2;

  /**
   * Mac0 structure and generates the Mac Tag. Mac0 Structure is partially defined MAC0_STRUCT - to
   * which detached content is added as payload. Detached content is as follows:
   * DeviceAuthenticationBytes = #6.24(bstr .cbor DeviceAuthentication) DeviceAuthentication = [
   * "DeviceAuthentication", SessionTranscript, DocType, ; Same as in mdoc response
   * DeviceNameSpacesBytes ; Same as in mdoc response ] The Mac Tag generated by digesting the data
   * is then appended to CoseMac0 structure defined in COSE_MAC0_STRUCT during presentation.
   */
  private static final byte[] MAC0_STRUCT = {
    (byte) 0x84, // Array of 4 elements
    0x64,
    0x4D,
    0x41,
    0x43,
    0x30, // text string of "MAC0"
    0x43,
    (byte) 0xA1,
    0x01,
    0x05, // protected
    0x40, // external aad empty byte string
    // payload which will be a byte string
  };

  private static final byte[] SIGN1_Signature1 = {
    0x6A, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x31
  };
  // alg = -7
  private static final byte[] SIGN1_ALG_ES256 = {(byte) 0xA1, 0x01, 0x26};
  // alg = -35
  private static final byte[] SIGN1_ALG_ES384 = {(byte) 0xA1, 0x01, 0x38, (byte) 34};
  static KeyAgreement mKeyAgreement;

  private final Object[] mPresentationPkg;

  private final boolean[] error;
  private final short[] errorCode;
  private final short[] mNsTable;
  private final short[] mElementTable;
  private final byte[] mMacTag;
  private final CBORDecoder mDecoder;
  private final CBOREncoder mEncoder;
  private final HMACKey mDeviceAuthKey;
  private final Signature mDeviceAuth;
  private final MdlSpecifications mMdlSpecifications;
  private short mNsTableEnd;
  private short mElementTableEnd;

  public DocumentRequest(MdlSpecifications specs) {
    mMdlSpecifications = specs;
    mPresentationPkg = JCSystem.makeTransientObjectArray((short) 1, JCSystem.CLEAR_ON_DESELECT);

    // Create element array with length one more than MAX ELEMENTS as the last entry will be
    // length of the element array.

    error = JCSystem.makeTransientBooleanArray((short) 1, JCSystem.CLEAR_ON_DESELECT);
    errorCode = JCSystem.makeTransientShortArray((short) 1, JCSystem.CLEAR_ON_DESELECT);
    mNsTable = JCSystem.makeTransientShortArray(MAX_NS_TABLE_SIZE, JCSystem.CLEAR_ON_DESELECT);
    mElementTable =
        JCSystem.makeTransientShortArray(MAX_ELEMENT_TABLE_SIZE, JCSystem.CLEAR_ON_DESELECT);
    // 32 bytes of tag + two bytes of CBOR bStr header (short encoding).
    mMacTag =
        JCSystem.makeTransientByteArray(
            (short) (MdlSpecifications.CBOR_MAC_TAG_SIZE + 2), JCSystem.CLEAR_ON_DESELECT);
    mDecoder = new CBORDecoder();
    mEncoder = new CBOREncoder();
    mDeviceAuthKey =
        (HMACKey) KeyBuilder.buildKey(KeyBuilder.TYPE_HMAC_TRANSIENT_RESET, (short) 512, false);
    mDeviceAuth = Signature.getInstance(Signature.ALG_HMAC_SHA_256, false);
    mKeyAgreement = KeyAgreement.getInstance(KeyAgreement.ALG_EC_SVDP_DH_PLAIN, false);
  }

  private static short mapAlg(short alg) {
    switch (alg) {
      case MdlSpecifications.ES256:
        return SEProvider.ES256;
      case MdlSpecifications.ES384:
        return SEProvider.ES384;
      case MdlSpecifications.ES512:
        return SEProvider.ES512;
    }
    return -1;
  }

  private static byte[] mapAlgToCOSEAlg(short alg) {
    switch (alg) {
      case SEProvider.ES256:
        return SIGN1_ALG_ES256;
      case SEProvider.ES384:
        return SIGN1_ALG_ES384;
    }
    return null;
  }

  /**
   * Generate thee sig structure and then verify the signature. detached content is as follows:
   * ReaderAuthenticationBytes = #6.24(bstr .cbor ReaderAuthentication) ReaderAuthentication = [
   * "ReaderAuthentication", SessionTranscript, ItemsRequestBytes ; ]
   */
  public boolean performReaderAuth(
      SEProvider se,
      byte[] buf,
      short itemsBytesStart,
      short itemsBytesLen,
      byte[] sessionTrans,
      short sessionTransStart,
      short sessionTransLen,
      short alg,
      byte[] pub,
      short pubKeyStart,
      short pubKeyLen,
      byte[] sign,
      short signStart,
      short signLen,
      byte[] scratch,
      short scratchStart,
      short scratchLen) {

    // Convert the sign to ASN1 format
    short len =
        se.convertCoseSign1SignatureToAsn1(
            sign, signStart, signLen, scratch, scratchStart, (short) (scratchLen - signLen));
    if (len < 0) {
      return false;
    }
    signLen = len;
    scratchLen -= signLen;
    signStart = scratchStart;
    scratchStart = (short) (signStart + signLen);
    sign = scratch;

    // Get the verifier
    Signature verifier = se.getVerifier(pub, pubKeyStart, pubKeyLen, alg, Signature.MODE_VERIFY);
    if (verifier == null) {
      return false;
    }

    // Calculate the payload len
    short readerAuthLen =
        (short)
            (1
                + // array header
                mMdlSpecifications.readerAuthentication.length
                + // "ReaderAuthentication"
                sessionTransLen
                + // SessionTranscript
                itemsBytesLen); // ItemsRequestBytes
    // And calculate the cbor tagged byte string length
    mEncoder.init(scratch, scratchStart, scratchLen);
    mEncoder.encodeTag((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    mEncoder.startByteString(readerAuthLen);
    short payloadLen = (short) (readerAuthLen + (mEncoder.getCurrentOffset() - scratchStart));

    // Start encoding Sig Structure
    mEncoder.init(scratch, scratchStart, scratchLen);
    // Array of 4
    mEncoder.startArray((short) 4);
    // "Signature1"
    mEncoder.encodeRawData(SIGN1_Signature1, (short) 0, (short) SIGN1_Signature1.length);
    // Protected header Bytes with map with one element of algorithm
    byte[] cborAlg = mapAlgToCOSEAlg(alg);
    mEncoder.startByteString((short) cborAlg.length);
    mEncoder.encodeRawData(cborAlg, (short) 0, (short) cborAlg.length);
    // external aad
    mEncoder.startByteString((short) 0);
    // payload
    mEncoder.startByteString(payloadLen);
    // payload is the detached content as follows
    // ReaderAuthenticationBytes - BStr with tag 24
    mEncoder.encodeTag((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    // start byte string
    mEncoder.startByteString(readerAuthLen);
    // ReaderAuthentication
    // Array of 3
    mEncoder.startArray((short) 3);
    // "ReaderAuthentication"
    mEncoder.encodeRawData(
        mMdlSpecifications.readerAuthentication,
        (short) 0,
        (short) mMdlSpecifications.readerAuthentication.length);
    // Now just digest this and then add Session Transcript and item bytes to the digest
    len = (short) (mEncoder.getCurrentOffset() - scratchStart);
    verifier.update(scratch, scratchStart, len);
    verifier.update(sessionTrans, sessionTransStart, sessionTransLen);
    boolean ret = verifier.verify(buf, itemsBytesStart, itemsBytesLen, sign, signStart, signLen);
    return ret;
  }

  public void reset() {
    mPresentationPkg[0] = null;
    error[0] = false;
    errorCode[0] = 0;
    mNsTableEnd = 0;
    mElementTableEnd = 0;
  }

  public byte[] getDeviceAuthMacTag() {
    return mMacTag;
  }

  public MdocPresentationPkg getDocument() {
    return (MdocPresentationPkg) mPresentationPkg[0];
  }

  public void setDocument(MdocPresentationPkg doc) {
    mPresentationPkg[0] = doc;
  }

  public void setError() {
    error[0] = true;
  }

  public boolean isError() {
    return error[0];
  }

  public void setErrorCode(short err) {
    errorCode[0] = err;
  }

  public short getDocType(byte[] buf, short start) {
    if (mPresentationPkg[0] != null) {
      return ((MdocPresentationPkg) mPresentationPkg[0]).getDocType(buf, start);
    }
    return -1;
  }

  boolean init(
      MdocPresentationPkg doc,
      Session session,
      byte[] buf,
      short nameSpacesStart,
      short nameSpacesLen,
      byte[] scratch,
      short scratchStart,
      short scratchLen) {
    reset();
    // init the decoder
    mDecoder.init(buf, nameSpacesStart, nameSpacesLen);
    if (mDecoder.getMajorType() != CBORBase.TYPE_MAP) {
      return false;
    }
    // Read the top map which contains namespaces as keys and data items as value.
    short numElements = mDecoder.readMajorType(CBORBase.TYPE_MAP);

    // For each requested namespace
    for (short i = 0; i < numElements; i++) {
      // Read the namespace key - If the namespace key is present in this document
      // Also, namespace must be text string
      short keyStart = mDecoder.getCurrentOffset();
      short keyLength = (short) (mDecoder.skipEntry() - keyStart);
      short nsEntryIndex = doc.findNsEntry(buf, keyStart, keyLength);
      // If namespace is not found then return false.
      if (nsEntryIndex < 0) {
        // Ignore unrecognized namespace and skip the corresponding data elements
        mDecoder.skipEntry();
        continue;
      }

      // Now read the value i.e. map of data elements
      if (mDecoder.getMajorType() != CBORBase.TYPE_MAP) {
        return false;
      }
      short dataElemCount = mDecoder.readMajorType(CBORBase.TYPE_MAP);
      // Save the namespace entryIndex
      mNsTable[(short) (mNsTableEnd + NS_KEY_ID_OFFSET)] = nsEntryIndex;
      mNsTable[(short) (mNsTableEnd + NS_ELEMENT_TABLE_INDEX)] = mElementTableEnd;
      mNsTable[(short) (mNsTableEnd + NS_ELEMENT_COUNT)] = 0;
      // For each data element requested in this namespace
      for (short j = 0; j < dataElemCount; j++) {
        // Resolve the data element key and find the corresponding entry
        keyStart = mDecoder.getCurrentOffset();
        keyLength = (short) (mDecoder.skipEntry() - keyStart);
        short elemEntryIndex = doc.findElementEntry(nsEntryIndex, buf, keyStart, keyLength);

        // TODO currently if element entry is not found we skip requested element.
        // This may need to change in future.
        if (elemEntryIndex >= 0) {
          mElementTable[mElementTableEnd++] = elemEntryIndex;
          // mElementTableEnd += doc.readElementRecord(mElementTable, mElementTableEnd,
          //    elemEntryIndex);
        }

        // TODO if required handle intentToRetain
        mDecoder.skipEntry(); // skip the requested element value - this is the intentToRetain
      }
      mNsTable[(short) (mNsTableEnd + NS_ELEMENT_COUNT)] =
          (short) (mElementTableEnd - mNsTable[(short) (mNsTableEnd + NS_ELEMENT_TABLE_INDEX)]);
      mNsTableEnd += NS_ARR_ENTRY_SIZE;
    }
    setDocument(doc);
    // At this we can generate device authentication mac tag.
    try {
      return generateDeviceAuthMacTag(session, scratch, scratchStart, scratchLen);
    } catch (Exception e) {
      return false;
    }
  }

  public short getSessionTranscriptStart(byte[] sessionTransBytes, short currentStart, short len) {
    // The digest includes session transcript and not the session transcript bytes. So decode
    // the session transcript from the transcript bytes.
    mDecoder.init(sessionTransBytes, (short) 2, Util.getShort(sessionTransBytes, (short) 0));
    mDecoder.readMajorType(CBORBase.TYPE_TAG);
    mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
    return mDecoder.getCurrentOffset();
  }

  public short decodeCoseSign1(
      byte[] buf,
      short readerAuth,
      short readerAuthLen,
      short[] tmpArray,
      byte[] scratch,
      short scratchStart) {
    short signLen = -1;
    short innerElemCount = 0;
    mDecoder.init(buf, readerAuth, readerAuthLen);
    try {
      if ((mDecoder.readMajorType(CBORBase.TYPE_ARRAY) != 4)
          || (mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING) <= 0)) {
        return -1;
      }
      // Read algorithm
      short elemCount = mDecoder.readMajorType(CBORBase.TYPE_MAP);
      boolean found = false;
      for (byte i = 0; i < elemCount; i++) {
        if (found) {
          mDecoder.skipEntry(); // skip key
          mDecoder.skipEntry(); // skip val
          continue;
        }
        short key = mDecoder.readInt8();
        if (key != (byte) 0x01) {
          mDecoder.skipEntry(); // skip value
        } else {
          found = true;
          short val = mDecoder.readInt8();
          tmpArray[0] = mapAlg(val);
          if (tmpArray[0] < 0) {
            return -1;
          }
        }
      }
      // Read certificates
      elemCount = mDecoder.readMajorType(CBORBase.TYPE_MAP);
      found = false;
      for (byte i = 0; i < elemCount; i++) {
        if (found) {
          mDecoder.skipEntry(); // skip key
          mDecoder.skipEntry(); // skip val
          continue;
        }
        short key = mDecoder.readInt8();
        if (key != (byte) 33) {
          mDecoder.skipEntry(); // skip value
        } else {
          found = true;
          short type = mDecoder.getMajorType();
          if (type == CBORBase.TYPE_BYTE_STRING) {
            tmpArray[1] = 1;
            tmpArray[2] = mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
            tmpArray[3] = mDecoder.getCurrentOffset();
            mDecoder.increaseOffset(tmpArray[2]);
          } else if (type == CBORBase.TYPE_ARRAY) {
            innerElemCount = mDecoder.readMajorType(CBORBase.TYPE_ARRAY);
            tmpArray[1] = innerElemCount;
            for (byte j = 1; j <= innerElemCount; j++) {
              short certLen = mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
              short certStart = mDecoder.getCurrentOffset();
              mDecoder.increaseOffset(certLen);
              tmpArray[(short) (j * 2)] = certLen;
              tmpArray[(short) ((j * 2) + 1)] = certStart;
            }
          } else {
            return -1;
          }
        }
      }
      // Payload = null
      if (mDecoder.getRawByte() != (byte) 0xF6) {
        return -1;
      }
      mDecoder.increaseOffset((short) 1);
      // Read signature
      signLen = mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
      mDecoder.readRawByteArray(scratch, scratchStart, signLen);
    } catch (ISOException exp) {
      return -1;
    }
    return signLen;
  }

  public boolean generateDeviceAuthMacTag(
      Session session, byte[] scratchPad, short start, short len) {
    // Initializes mDeviceAuth - this is HMac Signer.
    initDeviceAuth(session, scratchPad, start, len);
    // Create Mac Structure to generate CoseMac0.
    // Digest the partial Mac0 structure
    mDeviceAuth.update(MAC0_STRUCT, (short) 0, (short) MAC0_STRUCT.length);

    // Now add detached content which is tagged binary string and hence we need to know the
    // length before we can encode and digest it.
    // Calculate the length.
    short sessionTransLength = Util.getShort(session.mSessionTranscriptBytes, (short) 0);
    short sessionTransStart =
        getSessionTranscriptStart(session.mSessionTranscriptBytes, (short) 2, sessionTransLength);
    sessionTransLength -= (short) (sessionTransStart - 2);

    short docTypeLength = ((MdocPresentationPkg) mPresentationPkg[0]).getDocType(scratchPad, start);
    short detachedContentLen =
        (short)
            (
            // Cbor array with 4 elements (1)
            1
                +
                // "DeviceAuthentication" text string
                (short) mMdlSpecifications.deviceAuthentication.length
                +
                // Cbor Encoded Session Transcript length
                sessionTransLength
                +
                // doc type length
                docTypeLength
                + (short) 4); // no namespaces thus only 3 bytes of header
    short detachedContentBytesLen = detachedContentLen;
    // Now we can encode and digest the detached content
    mEncoder.init(scratchPad, start, len);
    if (detachedContentBytesLen < CBORBase.ENCODED_ONE_BYTE) {
      detachedContentBytesLen += 3; // SemTag (2) + bStr(1)
    } else if (detachedContentBytesLen < (short) 0x100) {
      detachedContentBytesLen += 4; // // SemTag (2) + bStr(2)
    } else if (detachedContentBytesLen <= (short) 0x7FFF) {
      detachedContentBytesLen += 5; // // SemTag (2) + bStr(3)
    } else {
      ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
    }

    mEncoder.startByteString(detachedContentBytesLen);
    // Add Tagged DeviceAuthenticationBytes
    mEncoder.encodeTag((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    mEncoder.startByteString(detachedContentLen);
    // Add the Device Authentication array as part of DeviceAuthenticationBytes
    mEncoder.startArray((short) 4);
    // Element 1: deviceAuthentication text string
    mEncoder.encodeRawData(
        mMdlSpecifications.deviceAuthentication,
        (short) 0,
        (short) mMdlSpecifications.deviceAuthentication.length);

    // Digest the partial encoded data at this point.
    mDeviceAuth.update(scratchPad, start, (short) (mEncoder.getCurrentOffset() - start));
    // Element 2: Session transcript
    mDeviceAuth.update(session.mSessionTranscriptBytes, sessionTransStart, sessionTransLength);
    // Element 3: doc type
    ((MdocPresentationPkg) mPresentationPkg[0]).getDocType(scratchPad, start);
    mDeviceAuth.update(scratchPad, start, docTypeLength);
    // Element 4: Encode and digest document name spaces - current it will be always zero
    mEncoder.init(scratchPad, start, len);
    mEncoder.encodeTag((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    mEncoder.startByteString((short) 1);
    mEncoder.startMap((short) 0);
    mDeviceAuth.update(scratchPad, start, (short) (mEncoder.getCurrentOffset() - start));

    // Now generate the mac tag
    mEncoder.init(mMacTag, (short) 0, (short) mMacTag.length);
    mEncoder.startByteString(MdlSpecifications.CBOR_MAC_TAG_SIZE);
    if (mDeviceAuth.sign(scratchPad, start, (short) 0, mMacTag, (short) 2)
        != MdlSpecifications.CBOR_MAC_TAG_SIZE) {
      return false;
    }
    return true;
  }

  void initDeviceAuth(Session session, byte[] scratch, short start, short len) {
    // Derive Device Secret for mdoc signing
    ECPrivateKey devicePrivKey = (ECPrivateKey) getDocument().getAuthKeyPair().getPrivate();
    mKeyAgreement.init(devicePrivKey);
    short pubLen = session.mEReaderKeyPub.getW(scratch, start);
    short secretStart = (short) (start + pubLen);
    short secretLen = mKeyAgreement.generateSecret(scratch, start, pubLen, scratch, secretStart);
    short outStart =
        (short)
            (secretStart
                + secretLen); // Util.arrayCopyNonAtomic(Session.mSalt, (short) 0, scratch,
                              // saltStart,saltLen);
    short outLen =
        session.hkdf(
            scratch, secretStart, secretLen, mMdlSpecifications.eMacKey, scratch, outStart);
    mDeviceAuthKey.setKey(scratch, outStart, outLen);
    mDeviceAuth.init(mDeviceAuthKey, Signature.MODE_SIGN);
  }

  short getNsCount() {
    return (short) (mNsTableEnd / NS_ARR_ENTRY_SIZE);
  }

  short getElementCountForNs(short nsIndex) {
    nsIndex = (short) (nsIndex * NS_ARR_ENTRY_SIZE);
    return mNsTable[(short) (nsIndex + NS_ELEMENT_COUNT)];
  }

  public short getElementStart(short nsIndex, short elemIndex) {
    nsIndex = (short) (nsIndex * NS_ARR_ENTRY_SIZE);
    short elemTableStart = mNsTable[(short) (nsIndex + NS_ELEMENT_TABLE_INDEX)];
    elemIndex = mElementTable[(short) ((elemIndex * ELEM_ARR_ENTRY_SIZE) + elemTableStart)];
    return ((MdocPresentationPkg) mPresentationPkg[0]).getElementStart(elemIndex);
  }

  public short getElementLen(short nsIndex, short elemIndex) {
    nsIndex = (short) (nsIndex * NS_ARR_ENTRY_SIZE);
    short elemTableStart = mNsTable[(short) (nsIndex + NS_ELEMENT_TABLE_INDEX)];
    elemIndex = mElementTable[(short) ((elemIndex * ELEM_ARR_ENTRY_SIZE) + elemTableStart)];
    return ((MdocPresentationPkg) mPresentationPkg[0]).getElementLen(elemIndex);
  }

  public short getNsId(short nsIndex, byte[] buf, short start) {
    nsIndex = (short) (nsIndex * NS_ARR_ENTRY_SIZE);
    short nsEntryIdx = mNsTable[(short) (nsIndex + NS_KEY_ID_OFFSET)];
    return ((MdocPresentationPkg) mPresentationPkg[0]).getNsId(nsEntryIdx, buf, start);
  }
}
