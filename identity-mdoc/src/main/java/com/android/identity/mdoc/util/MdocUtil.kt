/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.identity.mdoc.util

import com.android.identity.cbor.Bstr
import com.android.identity.cbor.Cbor
import com.android.identity.cbor.CborMap
import com.android.identity.cbor.RawCbor
import com.android.identity.cbor.Simple
import com.android.identity.cbor.Tagged
import com.android.identity.crypto.Algorithm
import com.android.identity.crypto.Certificate
import com.android.identity.crypto.CreateCertificateOption
import com.android.identity.crypto.Crypto
import com.android.identity.crypto.EcPrivateKey
import com.android.identity.crypto.EcPublicKey
import com.android.identity.crypto.X509v3Extension
import com.android.identity.crypto.javaX509Certificate
import com.android.identity.document.DocumentRequest
import com.android.identity.document.DocumentRequest.DataElement
import com.android.identity.document.NameSpacedData
import com.android.identity.mdoc.mso.StaticAuthDataParser.StaticAuthData
import com.android.identity.mdoc.request.DeviceRequestParser
import com.android.identity.util.Logger
import kotlinx.datetime.Instant
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.CRLDistPoint
import org.bouncycastle.asn1.x509.DistributionPoint
import org.bouncycastle.asn1.x509.DistributionPointName
import org.bouncycastle.asn1.x509.ExtendedKeyUsage
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.asn1.x509.GeneralName
import org.bouncycastle.asn1.x509.GeneralNames
import org.bouncycastle.asn1.x509.KeyPurposeId
import org.bouncycastle.asn1.x509.KeyUsage
import org.bouncycastle.util.BigIntegers
import kotlin.random.Random

/**
 * Utilities for working with mdoc data structures.
 *
 * On the issuance-side, [generateIssuerNameSpaces] and [stripIssuerNameSpaces] can be used with
 * [com.android.identity.mdoc.mso.MobileSecurityObjectGenerator] and
 * [calculateDigestsForNameSpace] can be used to prepare PII and multiple static authentication
 * data packages (each including signed MSOs).
 *
 * On the device-side, [mergeIssuerNamesSpaces] can be used to generate the `DeviceResponse` CBOR
 * from the above-mentioned PII and static authentication data packages.
 */
object MdocUtil {
    private const val TAG = "MdocUtil"

    /**
     * Generates randoms and digest identifiers for data.
     *
     * This generates data similar to `IssuerNameSpaces` CBOR as defined in ISO 18013-5:
     *
     * ```
     * IssuerNameSpaces = { ; Returned data elements for each namespace
     *   + NameSpace =&gt; [ + IssuerSignedItemBytes ]
     * }
     *
     * IssuerSignedItemBytes = #6.24(bstr .cbor IssuerSignedItem)
     *
     * IssuerSignedItem = {
     *   "digestID" : uint, ; Digest ID for issuer data authentication
     *   "random" : bstr, ; Random value for issuer data authentication
     *   "elementIdentifier" : DataElementIdentifier, ; Data element identifier
     *   "elementValue" : DataElementValue ; Data element value
     * }
     * ```
     * except that the data is returned using a native maps and lists. The returned
     * data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR. The digest identifies and randoms are
     * generated by this helper using the provided [Random] provider.
     *
     * @param data The name spaced data.
     * @param randomProvider A random provider used for generating digest identifiers and salts.
     * @param dataElementRandomSize The number of bytes to use for the salt for each data elements,
     * must be at least 16.
     * @param overrides Optionally, a map of namespaces into data element names into values for
     * overriding data in the provided [NameSpacedData] parameter.
     * @return The data described above.
     * @throws IllegalArgumentException if `dataElementRandomSize` is less than 16.
     */
    @JvmStatic
    fun generateIssuerNameSpaces(
        data: NameSpacedData,
        randomProvider: Random,
        dataElementRandomSize: Int,
        overrides: Map<String, Map<String, ByteArray>>?,
    ): Map<String, List<ByteArray>> {
        // ISO 18013-5 section 9.1.2.5 Message digest function says that random must
        // be at least 16 bytes long.
        require(dataElementRandomSize >= 16) {
            "Random size must be at least 16 bytes"
        }
        val ret = mutableMapOf<String, List<ByteArray>>()

        // Count number of data elements first.
        var numDataElements = 0
        for (nsName in data.nameSpaceNames) {
            numDataElements += data.getDataElementNames(nsName).size
        }
        val digestIds: MutableList<Long> = ArrayList()
        for (n in 0L until numDataElements) {
            digestIds.add(n)
        }
        digestIds.shuffle(randomProvider)
        val digestIt: Iterator<Long> = digestIds.iterator()
        for (nsName in data.nameSpaceNames) {
            var overridesByNameSpace: Map<String, ByteArray>? = null
            if (overrides != null) {
                overridesByNameSpace = overrides[nsName]
            }
            val list: MutableList<ByteArray> = ArrayList()
            for (elemName in data.getDataElementNames(nsName)) {
                var encodedValue: ByteArray? = data.getDataElement(nsName, elemName)
                val digestId = digestIt.next()
                val random = ByteArray(dataElementRandomSize)
                randomProvider.nextBytes(random)
                if (overridesByNameSpace != null) {
                    val overriddenValue = overridesByNameSpace[elemName]
                    if (overriddenValue != null) {
                        encodedValue = overriddenValue
                    }
                }
                val issuerSignedItem =
                    CborMap.builder()
                        .put("digestID", digestId)
                        .put("random", random)
                        .put("elementIdentifier", elemName)
                        .put("elementValue", RawCbor(encodedValue!!))
                        .end()
                        .build()
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val encodedIssuerSignedItemBytes = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
                list.add(encodedIssuerSignedItemBytes)
            }
            ret[nsName] = list
        }
        return ret
    }

    /**
     * Strips issuer name spaces.
     *
     * This takes a `IssuerNameSpaces` value calculated by [generateIssuerNameSpaces]
     * and returns a similar structure except where all `elementValue` values
     * in `IssuerSignedItem` are set to `null`.
     *
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param exceptions a map from name spaces into a list of data element names for where
     * the `elementValue` should not be removed.
     * @return A copy of the passed-in structure where data element value is set to `null`.
     * for every data element.
     */
    @JvmStatic
    fun stripIssuerNameSpaces(
        issuerNameSpaces: Map<String, List<ByteArray>>,
        exceptions: Map<String, List<String>>?,
    ): Map<String, List<ByteArray>> {
        val ret = mutableMapOf<String, List<ByteArray>>()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val list: MutableList<ByteArray> = ArrayList()
            var exceptionsForNamespace: List<String>? = null
            if (exceptions != null) {
                exceptionsForNamespace = exceptions[nameSpaceName]
            }
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                if (exceptionsForNamespace != null) {
                    val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                    if (exceptionsForNamespace.contains(elementIdentifier)) {
                        list.add(encodedIssuerSignedItemBytes)
                        continue
                    }
                }
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val modifiedEncodedIssuerSignedItem =
                    issuerSignedItemClearValue(encodedIssuerSignedItem)
                val modifiedEncodedIssuerSignedItemBytes =
                    Cbor.encode(
                        Tagged(24, Bstr(modifiedEncodedIssuerSignedItem)),
                    )
                list.add(modifiedEncodedIssuerSignedItemBytes)
            }
            ret[nameSpaceName] = list
        }
        return ret
    }

    /**
     * Calculates all digests in a given name space.
     *
     * @param nameSpaceName the name space to pick from the `issuerNameSpaces` map.
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param digestAlgorithm the digest algorithm to use, for example [Algorithm.SHA256].
     * @return a map from digest identifiers to the calculated digest.
     * @throws IllegalArgumentException if the digest algorithm isn't supported.
     */
    @JvmStatic
    fun calculateDigestsForNameSpace(
        nameSpaceName: String,
        issuerNameSpaces: Map<String, List<ByteArray>>,
        digestAlgorithm: Algorithm,
    ): Map<Long, ByteArray> {
        val list =
            issuerNameSpaces[nameSpaceName]
                ?: throw IllegalArgumentException("No namespace $nameSpaceName in IssuerNameSpaces")
        val ret: MutableMap<Long, ByteArray> = LinkedHashMap()
        for (encodedIssuerSignedItemBytes in list) {
            val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
            val digestId = issuerSignedItem["digestID"].asNumber
            ret[digestId] = Crypto.digest(digestAlgorithm, encodedIssuerSignedItemBytes)
        }
        return ret
    }

    // Note: this also unwraps the bstr tagging of the IssuerSignedItem!
    private fun calcIssuerSignedItemMap(issuerNameSpaces: Map<String, List<ByteArray>>): Map<String, Map<String, ByteArray>> {
        val ret: MutableMap<String, Map<String, ByteArray>> = LinkedHashMap()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val innerMap: MutableMap<String, ByteArray> = LinkedHashMap()
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                innerMap[elementIdentifier] = Cbor.encode(issuerSignedItem)
            }
            ret[nameSpaceName] = innerMap
        }
        return ret
    }

    private fun lookupIssuerSignedMap(
        issuerSignedMap: Map<String, Map<String, ByteArray>>,
        nameSpaceName: String,
        dataElementName: String,
    ): ByteArray? {
        val innerMap = issuerSignedMap[nameSpaceName] ?: return null
        return innerMap[dataElementName]
    }

    /**
     * Combines document data with static authentication data for a given request.
     *
     * This goes through all data element name in a given [DocumentRequest] and
     * for each data element name, looks up `documentData` and `staticAuthData`
     * for the value and if present, will include that in the result. Data elements with
     * [DocumentRequest.DataElement.doNotSend] set to `true` are ignored.
     *
     * The result is intended to mimic `IssuerNameSpaces` CBOR as defined
     * in ISO 18013-5 except that the data is returned using a native maps and lists.
     * The returned data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR.
     *
     * @param request a [DocumentRequest] indicating which name spaces and data
     * element names to include in the result.
     * @param documentData Document data, organized by name space.
     * @param staticAuthData Static authentication data.
     * @return A map described above.
     */
    @JvmStatic
    fun mergeIssuerNamesSpaces(
        request: DocumentRequest,
        documentData: NameSpacedData,
        staticAuthData: StaticAuthData,
    ): Map<String, MutableList<ByteArray>> {
        val issuerSignedItemMap = calcIssuerSignedItemMap(staticAuthData.digestIdMapping)
        val issuerSignedData: MutableMap<String, MutableList<ByteArray>> = LinkedHashMap()
        for ((nameSpaceName, dataElementName, _, doNotSend) in request.requestedDataElements) {
            if (doNotSend) {
                continue
            }
            if (!documentData.hasDataElement(nameSpaceName, dataElementName)) {
                Logger.d(
                    TAG,
                    "No data element in document for nameSpace $nameSpaceName " +
                        " dataElementName $dataElementName",
                )
                continue
            }
            val value = documentData.getDataElement(nameSpaceName, dataElementName)
            val encodedIssuerSignedItemMaybeWithoutValue =
                lookupIssuerSignedMap(issuerSignedItemMap, nameSpaceName, dataElementName)
            if (encodedIssuerSignedItemMaybeWithoutValue == null) {
                Logger.w(TAG, "No IssuerSignedItem for $nameSpaceName $dataElementName")
                continue
            }
            var encodedIssuerSignedItem: ByteArray?
            encodedIssuerSignedItem =
                if (hasElementValue(encodedIssuerSignedItemMaybeWithoutValue)) {
                    encodedIssuerSignedItemMaybeWithoutValue
                } else {
                    issuerSignedItemSetValue(encodedIssuerSignedItemMaybeWithoutValue, value)
                }
            val list = issuerSignedData.computeIfAbsent(nameSpaceName) { k: String? -> ArrayList() }

            // We need a tagged bstr here
            val taggedEncodedIssuerSignedItem = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
            list.add(taggedEncodedIssuerSignedItem)
        }
        return issuerSignedData
    }

    private fun hasElementValue(encodedIssuerSignedItem: ByteArray): Boolean =
        Cbor.decode(encodedIssuerSignedItem)["elementValue"] != Simple.NULL

    /**
     * Helper function to generate a [DocumentRequest].
     *
     * @param documentRequest a [com.android.identity.mdoc.request.DeviceRequestParser.DocRequest].
     * @return a [DocumentRequest] representing for the given [com.android.identity.mdoc.request.DeviceRequestParser.DocRequest].
     */
    @JvmStatic
    fun generateDocumentRequest(documentRequest: DeviceRequestParser.DocRequest): DocumentRequest {
        val elements: MutableList<DataElement> = ArrayList()
        for (namespaceName in documentRequest.namespaces) {
            for (dataElementName in documentRequest.getEntryNames(namespaceName!!)) {
                val intentToRetain =
                    documentRequest.getIntentToRetain(namespaceName, dataElementName!!)
                elements.add(DataElement(namespaceName, dataElementName, intentToRetain, false))
            }
        }
        return DocumentRequest(elements)
    }

    /**
     * Generates a self-signed IACA certificate according to ISO/IEC 18013-5:2021 Annex B.1.2.
     *
     * @param iacaKey the private key.
     * @param subject the value to use for subject and issuer, e.g. "CN=Test IACA,C=UT".
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @param issuerAltName the issuer alternative name (see RFC 5280 section 4.2.1.7),
     * e.g. "http://issuer.example.com/informative/web/page".
     * @param crlUrl the URL for revocation (see RFC 5280 section 4.2.1.13).
     * @return a [Certificate] with all the required extensions.
     */
    @JvmStatic
    fun generateIacaCertificate(
        iacaKey: EcPrivateKey,
        subject: String,
        validFrom: Instant,
        validUntil: Instant,
        issuerAltName: String,
        crlUrl: String,
    ): Certificate {
        // Requirements for the IACA certificate is defined in ISO/IEC 18013-5:2021 Annex B

        // From 18013-5 table B.1: countryName is mandatory
        //                         stateOrProvinceName is optional.
        //                         organizationName is optional.
        //                         commonName shall be present.
        //                         serialNumber is optional.
        //

        // From 18013-5 Annex B: 3-5 years is recommended
        //                       Maximum of 20 years after “Not before” date

        val curve = iacaKey.curve

        // From 18013-5 table B.1: Non-sequential positive, non-zero integer, shall contain
        //                         at least 63 bits of output from a CSPRNG, should contain at
        //                         least 71 bits of output from a CSPRNG, maximum 20 octets.
        val serial = BigIntegers.fromUnsignedByteArray(Random.Default.nextBytes(16)).toString()

        val extensions = mutableListOf<X509v3Extension>()

        // From 18013-5 table B.1: critical: Key certificate signature + CRL signature bits set
        extensions.add(
            X509v3Extension(
                Extension.keyUsage.toString(),
                true,
                KeyUsage(KeyUsage.cRLSign + KeyUsage.keyCertSign).encoded,
            ),
        )

        // From 18013-5 table B.1: non-critical, Email or URL

        extensions.add(
            X509v3Extension(
                Extension.issuerAlternativeName.toString(),
                false,
                GeneralName(GeneralName.uniformResourceIdentifier, issuerAltName).encoded,
            ),
        )

        // From 18013-5 table B.1: critical, CA=true, pathLenConstraint=0
        extensions.add(
            X509v3Extension(
                Extension.basicConstraints.toString(),
                true,
                BasicConstraints(0).encoded,
            ),
        )

        // From 18013-5 table B.1: non-critical, The ‘reasons’ and ‘cRL Issuer’
        // fields shall not be used.
        val distributionPoint =
            DistributionPoint(
                DistributionPointName(
                    GeneralNames(
                        GeneralName(GeneralName.uniformResourceIdentifier, crlUrl),
                    ),
                ),
                null,
                null,
            )
        extensions.add(
            X509v3Extension(
                Extension.cRLDistributionPoints.toString(),
                false,
                CRLDistPoint(listOf(distributionPoint).toTypedArray()).encoded,
            ),
        )

        return Crypto.createX509v3Certificate(
            iacaKey.publicKey,
            iacaKey,
            null,
            curve.defaultSigningAlgorithm,
            serial,
            subject,
            subject,
            validFrom,
            validUntil,
            // 18013-5 Annex C requires both of these to be present
            setOf(
                CreateCertificateOption.INCLUDE_SUBJECT_KEY_IDENTIFIER,
                CreateCertificateOption.INCLUDE_AUTHORITY_KEY_IDENTIFIER_AS_SUBJECT_KEY_IDENTIFIER,
            ),
            extensions,
        )
    }

    /**
     * Generates a Document Signing certificate according to ISO/IEC 18013-5:2021 Annex B.1.4.
     *
     * @param iacaCert the IACA certificate the DS certificate.
     * @param iacaKey the private key for the IACA certificate.
     * @param dsKey the public part of the DS key.
     * @param subject the value to use for subject, e.g. "CN=Test DS,C=UT".
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @param issuerAltName the issuer alternative name (see RFC 5280 section 4.2.1.7),
     * e.g. "http://issuer.example.com/informative/web/page".
     * @param crlUrl the URL for revocation (see RFC 5280 section 4.2.1.13).
     * @return a [Certificate] with all the required extensions.
     */
    @JvmStatic
    fun generateDsCertificate(
        iacaCert: Certificate,
        iacaKey: EcPrivateKey,
        dsKey: EcPublicKey,
        subject: String,
        validFrom: Instant,
        validUntil: Instant,
    ): Certificate {
        val iacaCertJava = iacaCert.javaX509Certificate

        // Must be same exact binary value as the subject of IACA certificate.
        val issuer = iacaCertJava.subjectX500Principal.toString()

        val serial = BigIntegers.fromUnsignedByteArray(Random.Default.nextBytes(16)).toString()

        val extensions = mutableListOf<X509v3Extension>()

        extensions.add(
            X509v3Extension(
                Extension.keyUsage.toString(),
                true,
                KeyUsage(KeyUsage.digitalSignature).encoded,
            ),
        )

        extensions.add(
            X509v3Extension(
                Extension.extendedKeyUsage.toString(),
                true,
                ExtendedKeyUsage(
                    KeyPurposeId.getInstance(ASN1ObjectIdentifier("1.0.18013.5.1.2")),
                ).encoded,
            ),
        )

        // Copy cRLDistributionPoints and issuerAlternativeName from IACA cert
        extensions.add(
            X509v3Extension(
                Extension.cRLDistributionPoints.toString(),
                false,
                iacaCertJava.getExtensionValue(Extension.cRLDistributionPoints.toString()),
            ),
        )
        extensions.add(
            X509v3Extension(
                Extension.issuerAlternativeName.toString(),
                false,
                iacaCertJava.getExtensionValue(Extension.issuerAlternativeName.toString()),
            ),
        )

        val documentSigningKeyCert =
            Crypto.createX509v3Certificate(
                dsKey,
                iacaKey,
                iacaCert,
                Algorithm.ES256,
                serial,
                subject,
                issuer,
                validFrom,
                validUntil,
                setOf(
                    CreateCertificateOption.INCLUDE_SUBJECT_KEY_IDENTIFIER,
                    CreateCertificateOption.INCLUDE_AUTHORITY_KEY_IDENTIFIER_FROM_SIGNING_KEY_CERTIFICATE,
                ),
                extensions,
            )

        return documentSigningKeyCert
    }

    private fun issuerSignedItemClearValue(encodedIssuerSignedItem: ByteArray): ByteArray {
        val encodedNullValue = Cbor.encode(Simple.NULL)
        return issuerSignedItemSetValue(encodedIssuerSignedItem, encodedNullValue)
    }

    private fun issuerSignedItemSetValue(
        encodedIssuerSignedItem: ByteArray,
        encodedElementValue: ByteArray,
    ): ByteArray {
        val map = Cbor.decode(encodedIssuerSignedItem)
        val builder = CborMap.builder()
        for (key in map.asMap.keys) {
            if (key.asTstr == "elementValue") {
                builder.put(key, RawCbor(encodedElementValue))
            } else {
                builder.put(key, map[key])
            }
        }
        return Cbor.encode(builder.end().build())
    }
}
