package org.multipaz.sdjwt.presentation

import org.multipaz.crypto.Crypto
import org.multipaz.crypto.EcPublicKey
import org.multipaz.crypto.EcSignature
import org.multipaz.sdjwt.SdJwtVerifiableCredential
import org.multipaz.sdjwt.vc.JwtBody
import org.multipaz.util.Logger
import org.multipaz.util.fromBase64Url
import org.multipaz.util.toBase64Url
import kotlinx.datetime.Instant

private const val TAG = "SdJwtVerifiablePresentation"

/**
 * A presentation of a SD-JWT. It consists of:
 * (1) an SD-JWT (which itself has the form
 *     <header>.<body>.<signature>~<disclosure>...~<disclosure>~
 *     )
 * (2) a key binding header followed by a period
 * (3) a key binding body followed by a period
 * (4) a signature over the key binding header and key binding body
 *
 * The last three components are called a "Key Binding JWT".
 *
 */
class SdJwtVerifiablePresentation(
    val sdJwtVc: SdJwtVerifiableCredential,
    val keyBindingHeader: String,
    val keyBindingBody: String,
    val keyBindingSignature: String,
) {

    fun getAttributeValue(key: String) = sdJwtVc.getAttributeValue(key)

    private fun verifyHolderSignature(key: EcPublicKey): KeyBindingBody {
        val keyBindingHeaderObj = KeyBindingHeader.fromString(keyBindingHeader)
        val keyBindingBodyObj = KeyBindingBody.fromString(keyBindingBody)

        // compare the hash of the VC against what's in the key binding JWT
        val sdHash = Crypto.digest(sdJwtVc.sdHashAlg, sdJwtVc.toString().encodeToByteArray()).toBase64Url()
        if (sdHash != keyBindingBodyObj.sdHash) {
            throw IllegalStateException("hash in key binding JWT didn't match SD-JWT")
        }

        val toBeVerified = "$keyBindingHeader.$keyBindingBody".encodeToByteArray()
        val signature = EcSignature.fromCoseEncoded(keyBindingSignature.fromBase64Url())

        if (!Crypto.checkSignature(key, toBeVerified, keyBindingHeaderObj.algorithm, signature)) {
            throw IllegalStateException("Signature verification failed")
        }

        return keyBindingBodyObj
    }

    /**
     * Verifies that the SD-JWT presentation contains a key binding JWT that is signed
     * by the public key mentioned in the SD-JWT, proving that the presentation was
     * generated by the principal to which the SD-JWT was issued.
     *
     * The caller MUST pass in three functions that will validate the nonce, audience, and
     * creation time of the SD-JWT presentation.
     *
     * @return True if the presentation is key-bound and the binding is valid. False if it is
     *     not key-bound. Throws an exception if the binding is invalid.
     */
    fun verifyKeyBinding(
        checkNonce: (String) -> Boolean,
        checkAudience: (String) -> Boolean,
        checkCreationTime: (Instant) -> Boolean,
    ): Boolean {
        val jwtBody = JwtBody.fromString(sdJwtVc.body)
        if (jwtBody.publicKey == null) {
            // Non-keybound credential. No verification needed.
            Logger.i(TAG, "verifyKeyBinding found a body with no public key. Assuming a"
                    + " non-keybound credential.")
            // TODO: If we're expecting a keybound credential, this should be an error.
            return false
        }

        val key = jwtBody.publicKey?.asEcPublicKey ?:
            throw MalformedSdJwtPresentationError("couldn't parse public holder key from JWT: ${sdJwtVc.body}")
        val keyBindingBodyObj = verifyHolderSignature(key)

        if (!checkNonce(keyBindingBodyObj.nonce)) {
             throw IllegalStateException("nonce didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }

        if (!checkAudience(keyBindingBodyObj.audience)) {
            throw IllegalStateException("audience didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }

        if (!checkCreationTime(keyBindingBodyObj.creationTime)) {
            throw IllegalStateException("creation time didn't verify in key binding JWT: ${keyBindingBodyObj.toString()}")
        }
        return true
    }

    override fun toString() = "$sdJwtVc$keyBindingHeader.$keyBindingBody.$keyBindingSignature"

    companion object {
        fun fromString(input: String): SdJwtVerifiablePresentation {
            val lastTildePosition = input.lastIndexOf('~')

            if (lastTildePosition == -1) {
                throw MalformedSdJwtPresentationError("couldn't find ~ in SD-JWT $input")
            }

            val sdJwtString = input.substring(0, lastTildePosition + 1)
            val keyBindingJwtString = input.substring(lastTildePosition + 1)

            val sdJwt = SdJwtVerifiableCredential.fromString(sdJwtString)

            val keyBindingJwtParts = keyBindingJwtString.split(".")

            if (keyBindingJwtParts.size != 3) {
                throw MalformedSdJwtPresentationError("key binding JWT didn't consist of three parts: $keyBindingJwtString")
            }

            val (keyBindingHeader, keyBindingBody, keyBindingSignature) = keyBindingJwtParts

            return SdJwtVerifiablePresentation(
                sdJwt,
                keyBindingHeader,
                keyBindingBody,
                keyBindingSignature)
        }
    }

    class MalformedSdJwtPresentationError(message: String): Exception(message)
}