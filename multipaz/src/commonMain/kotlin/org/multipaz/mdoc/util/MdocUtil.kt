/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.multipaz.mdoc.util

import org.multipaz.asn1.ASN1
import org.multipaz.asn1.ASN1Encoding
import org.multipaz.asn1.ASN1Integer
import org.multipaz.asn1.ASN1ObjectIdentifier
import org.multipaz.asn1.ASN1Sequence
import org.multipaz.asn1.ASN1TagClass
import org.multipaz.asn1.ASN1TaggedObject
import org.multipaz.asn1.OID
import org.multipaz.cbor.Bstr
import org.multipaz.cbor.Cbor
import org.multipaz.cbor.CborMap
import org.multipaz.cbor.RawCbor
import org.multipaz.cbor.Simple
import org.multipaz.cbor.Tagged
import org.multipaz.document.DocumentRequest
import org.multipaz.document.DocumentRequest.DataElement
import org.multipaz.document.NameSpacedData
import org.multipaz.crypto.Algorithm
import org.multipaz.crypto.Crypto
import org.multipaz.crypto.EcPrivateKey
import org.multipaz.crypto.EcPublicKey
import org.multipaz.crypto.X500Name
import org.multipaz.crypto.X509Cert
import org.multipaz.crypto.X509KeyUsage
import org.multipaz.documenttype.DocumentTypeRepository
import org.multipaz.mdoc.credential.MdocCredential
import org.multipaz.mdoc.mso.StaticAuthDataParser
import org.multipaz.mdoc.mso.StaticAuthDataParser.StaticAuthData
import org.multipaz.mdoc.request.DeviceRequestParser
import org.multipaz.request.MdocRequest
import org.multipaz.request.MdocRequestedClaim
import org.multipaz.request.Requester
import org.multipaz.util.Logger
import kotlinx.datetime.Instant
import kotlin.random.Random

/**
 * Utilities for working with mdoc data structures.
 *
 * On the issuance-side, [generateIssuerNameSpaces] and [stripIssuerNameSpaces] can be used with
 * [org.multipaz.mdoc.mso.MobileSecurityObjectGenerator] and
 * [calculateDigestsForNameSpace] can be used to prepare PII and multiple static authentication
 * data packages (each including signed MSOs).
 *
 * On the device-side, [mergeIssuerNamesSpaces] can be used to generate the `DeviceResponse` CBOR
 * from the above-mentioned PII and static authentication data packages.
 */
object MdocUtil {
    private const val TAG = "MdocUtil"

    /**
     * Generates randoms and digest identifiers for data.
     *
     * This generates data similar to `IssuerNameSpaces` CBOR as defined in ISO 18013-5:
     *
     * ```
     * IssuerNameSpaces = { ; Returned data elements for each namespace
     *   + NameSpace =&gt; [ + IssuerSignedItemBytes ]
     * }
     *
     * IssuerSignedItemBytes = #6.24(bstr .cbor IssuerSignedItem)
     *
     * IssuerSignedItem = {
     *   "digestID" : uint, ; Digest ID for issuer data authentication
     *   "random" : bstr, ; Random value for issuer data authentication
     *   "elementIdentifier" : DataElementIdentifier, ; Data element identifier
     *   "elementValue" : DataElementValue ; Data element value
     * }
     * ```
     * except that the data is returned using a native maps and lists. The returned
     * data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR. The digest identifies and randoms are
     * generated by this helper using the provided [Random] provider.
     *
     * @param data The name spaced data.
     * @param randomProvider A random provider used for generating digest identifiers and salts.
     * @param dataElementRandomSize The number of bytes to use for the salt for each data elements,
     * must be at least 16.
     * @param overrides Optionally, a map of namespaces into data element names into values for
     * overriding data in the provided [NameSpacedData] parameter.
     * @return The data described above.
     * @throws IllegalArgumentException if `dataElementRandomSize` is less than 16.
     */
    fun generateIssuerNameSpaces(
        data: NameSpacedData,
        randomProvider: Random,
        dataElementRandomSize: Int,
        overrides: Map<String, Map<String, ByteArray>>?
    ): Map<String, List<ByteArray>> {
        // ISO 18013-5 section 9.1.2.5 Message digest function says that random must
        // be at least 16 bytes long.
        require(dataElementRandomSize >= 16) {
            "Random size must be at least 16 bytes"
        }
        val ret = mutableMapOf<String, List<ByteArray>>()

        // Count number of data elements first.
        var numDataElements = 0
        for (nsName in data.nameSpaceNames) {
            numDataElements += data.getDataElementNames(nsName).size
        }
        val digestIds: MutableList<Long> = ArrayList()
        for (n in 0L until numDataElements) {
            digestIds.add(n)
        }
        digestIds.shuffle(randomProvider)
        val digestIt: Iterator<Long> = digestIds.iterator()
        for (nsName in data.nameSpaceNames) {
            var overridesByNameSpace: Map<String, ByteArray>? = null
            if (overrides != null) {
                overridesByNameSpace = overrides[nsName]
            }
            val list: MutableList<ByteArray> = ArrayList()
            for (elemName in data.getDataElementNames(nsName)) {
                var encodedValue: ByteArray? = data.getDataElement(nsName, elemName)
                val digestId = digestIt.next()
                val random = ByteArray(dataElementRandomSize)
                randomProvider.nextBytes(random)
                if (overridesByNameSpace != null) {
                    val overriddenValue = overridesByNameSpace[elemName]
                    if (overriddenValue != null) {
                        encodedValue = overriddenValue
                    }
                }
                val issuerSignedItem = CborMap.builder()
                    .put("digestID", digestId)
                    .put("random", random)
                    .put("elementIdentifier", elemName)
                    .put("elementValue", RawCbor(encodedValue!!))
                    .end()
                    .build()
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val encodedIssuerSignedItemBytes = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
                list.add(encodedIssuerSignedItemBytes)
            }
            ret[nsName] = list
        }
        return ret
    }

    /**
     * Strips issuer name spaces.
     *
     * This takes a `IssuerNameSpaces` value calculated by [generateIssuerNameSpaces]
     * and returns a similar structure except where all `elementValue` values
     * in `IssuerSignedItem` are set to `null`.
     *
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param exceptions a map from name spaces into a list of data element names for where
     * the `elementValue` should not be removed.
     * @return A copy of the passed-in structure where data element value is set to `null`.
     * for every data element.
     */
    fun stripIssuerNameSpaces(
        issuerNameSpaces: Map<String, List<ByteArray>>,
        exceptions: Map<String, List<String>>?
    ): Map<String, List<ByteArray>> {
        val ret = mutableMapOf<String, List<ByteArray>>()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val list: MutableList<ByteArray> = ArrayList()
            var exceptionsForNamespace: List<String>? = null
            if (exceptions != null) {
                exceptionsForNamespace = exceptions[nameSpaceName]
            }
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                if (exceptionsForNamespace != null) {
                    val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                    if (exceptionsForNamespace.contains(elementIdentifier)) {
                        list.add(encodedIssuerSignedItemBytes)
                        continue
                    }
                }
                val encodedIssuerSignedItem = Cbor.encode(issuerSignedItem)
                val modifiedEncodedIssuerSignedItem =
                    issuerSignedItemClearValue(encodedIssuerSignedItem)
                val modifiedEncodedIssuerSignedItemBytes = Cbor.encode(
                    Tagged(24, Bstr(modifiedEncodedIssuerSignedItem))
                )
                list.add(modifiedEncodedIssuerSignedItemBytes)
            }
            ret[nameSpaceName] = list
        }
        return ret
    }

    /**
     * Calculates all digests in a given name space.
     *
     * @param nameSpaceName the name space to pick from the `issuerNameSpaces` map.
     * @param issuerNameSpaces a map from name spaces into a list of `IssuerSignedItemBytes`.
     * @param digestAlgorithm the digest algorithm to use, for example [Algorithm.SHA256].
     * @return a map from digest identifiers to the calculated digest.
     * @throws IllegalArgumentException if the digest algorithm isn't supported.
     */
    fun calculateDigestsForNameSpace(
        nameSpaceName: String,
        issuerNameSpaces: Map<String, List<ByteArray>>,
        digestAlgorithm: Algorithm
    ): Map<Long, ByteArray> {
        val list = issuerNameSpaces[nameSpaceName]
            ?: throw IllegalArgumentException("No namespace $nameSpaceName in IssuerNameSpaces")
        val ret: MutableMap<Long, ByteArray> = LinkedHashMap()
        for (encodedIssuerSignedItemBytes in list) {
            val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
            val digestId = issuerSignedItem["digestID"].asNumber
            ret[digestId] = Crypto.digest(digestAlgorithm, encodedIssuerSignedItemBytes)
        }
        return ret
    }

    // Note: this also unwraps the bstr tagging of the IssuerSignedItem!
    private fun calcIssuerSignedItemMap(
        issuerNameSpaces: Map<String, List<ByteArray>>
    ): Map<String, Map<String, ByteArray>> {
        val ret: MutableMap<String, Map<String, ByteArray>> = LinkedHashMap()
        for (nameSpaceName in issuerNameSpaces.keys) {
            val innerMap: MutableMap<String, ByteArray> = LinkedHashMap()
            for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
                val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
                val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
                innerMap[elementIdentifier] = Cbor.encode(issuerSignedItem)
            }
            ret[nameSpaceName] = innerMap
        }
        return ret
    }

    private fun lookupIssuerSignedMap(
        issuerSignedMap: Map<String, Map<String, ByteArray>>,
        nameSpaceName: String,
        dataElementName: String
    ): ByteArray? {
        val innerMap = issuerSignedMap[nameSpaceName] ?: return null
        return innerMap[dataElementName]
    }

    /**
     * Combines document data with static authentication data for a given request.
     *
     * This goes through all data element name in a given [DocumentRequest] and
     * for each data element name, looks up `documentData` and `staticAuthData`
     * for the value and if present, will include that in the result. Data elements with
     * [DocumentRequest.DataElement.doNotSend] set to `true` are ignored.
     *
     * The result is intended to mimic `IssuerNameSpaces` CBOR as defined
     * in ISO 18013-5 except that the data is returned using a native maps and lists.
     * The returned data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR.
     *
     * @param request a [DocumentRequest] indicating which name spaces and data
     * element names to include in the result.
     * @param documentData Document data, organized by name space.
     * @param staticAuthData Static authentication data.
     * @return A map described above.
     */
    fun mergeIssuerNamesSpaces(
        request: DocumentRequest,
        documentData: NameSpacedData,
        staticAuthData: StaticAuthData
    ): Map<String, MutableList<ByteArray>> {
        val issuerSignedItemMap = calcIssuerSignedItemMap(staticAuthData.digestIdMapping)
        val issuerSignedData: MutableMap<String, MutableList<ByteArray>> = LinkedHashMap()
        for ((nameSpaceName, dataElementName, _, doNotSend) in request.requestedDataElements) {
            if (doNotSend) {
                continue
            }
            if (!documentData.hasDataElement(nameSpaceName, dataElementName)) {
                Logger.d(TAG,
                    "No data element in document for nameSpace $nameSpaceName "
                            + " dataElementName $dataElementName"
                )
                continue
            }
            val value = documentData.getDataElement(nameSpaceName, dataElementName)
            val encodedIssuerSignedItemMaybeWithoutValue =
                lookupIssuerSignedMap(issuerSignedItemMap, nameSpaceName, dataElementName)
            if (encodedIssuerSignedItemMaybeWithoutValue == null) {
                Logger.w(TAG, "No IssuerSignedItem for $nameSpaceName $dataElementName")
                continue
            }
            var encodedIssuerSignedItem: ByteArray?
            encodedIssuerSignedItem =
                if (hasElementValue(encodedIssuerSignedItemMaybeWithoutValue)) {
                    encodedIssuerSignedItemMaybeWithoutValue
                } else {
                    issuerSignedItemSetValue(encodedIssuerSignedItemMaybeWithoutValue, value)
                }
            val list = issuerSignedData.getOrPut(nameSpaceName) { ArrayList() }

            // We need a tagged bstr here
            val taggedEncodedIssuerSignedItem = Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
            list.add(taggedEncodedIssuerSignedItem)
        }
        return issuerSignedData
    }

    /**
     * Combines document data with static authentication data for a given request.
     *
     * This goes through all data element name in a given set of name spaces and data elements
     * and for each data element name, looks up `documentData` and `staticAuthData`
     * for the value and if present, will include that in the result.
     *
     * The result is intended to mimic `IssuerNameSpaces` CBOR as defined
     * in ISO 18013-5 except that the data is returned using a native maps and lists.
     * The returned data is a map from name spaces into a list of the bytes of the
     * `IssuerSignedItemBytes` CBOR.
     *
     * @param request a [DocumentRequest] indicating which name spaces and data
     * element names to include in the result.
     * @param documentData Document data, organized by name space.
     * @param staticAuthData Static authentication data.
     * @return A map described above.
     */
    fun mergeIssuerNamesSpaces(
        dataElements: Map<String, List<String>>,
        documentData: NameSpacedData,
        staticAuthData: StaticAuthData
    ): Map<String, MutableList<ByteArray>> {
        val issuerSignedItemMap = calcIssuerSignedItemMap(staticAuthData.digestIdMapping)
        val issuerSignedData: MutableMap<String, MutableList<ByteArray>> = LinkedHashMap()
        for ((nameSpaceName, dataElementsInNamespace) in dataElements) {
            for (dataElementName in dataElementsInNamespace) {
                if (!documentData.hasDataElement(nameSpaceName, dataElementName)) {
                    Logger.d(TAG,
                        "No data element in document for nameSpace $nameSpaceName "
                                + " dataElementName $dataElementName"
                    )
                    continue
                }
                val value = documentData.getDataElement(nameSpaceName, dataElementName)
                val encodedIssuerSignedItemMaybeWithoutValue =
                    lookupIssuerSignedMap(issuerSignedItemMap, nameSpaceName, dataElementName)
                if (encodedIssuerSignedItemMaybeWithoutValue == null) {
                    Logger.w(TAG, "No IssuerSignedItem for $nameSpaceName $dataElementName")
                    continue
                }
                var encodedIssuerSignedItem: ByteArray?
                encodedIssuerSignedItem =
                    if (hasElementValue(encodedIssuerSignedItemMaybeWithoutValue)) {
                        encodedIssuerSignedItemMaybeWithoutValue
                    } else {
                        issuerSignedItemSetValue(encodedIssuerSignedItemMaybeWithoutValue, value)
                    }
                val list = issuerSignedData.getOrPut(nameSpaceName) { ArrayList() }

                // We need a tagged bstr here
                val taggedEncodedIssuerSignedItem =
                    Cbor.encode(Tagged(24, Bstr(encodedIssuerSignedItem)))
                list.add(taggedEncodedIssuerSignedItem)
            }
        }
        return issuerSignedData
    }

    private fun hasElementValue(encodedIssuerSignedItem: ByteArray): Boolean =
        Cbor.decode(encodedIssuerSignedItem)["elementValue"] != Simple.NULL

    /**
     * Helper function to generate a [DocumentRequest].
     *
     * @param documentRequest a [org.multipaz.mdoc.request.DeviceRequestParser.DocRequest].
     * @return a [DocumentRequest] representing for the given [org.multipaz.mdoc.request.DeviceRequestParser.DocRequest].
     */
    fun generateDocumentRequest(
        documentRequest: DeviceRequestParser.DocRequest
    ): DocumentRequest {
        val elements: MutableList<DataElement> = ArrayList()
        for (namespaceName in documentRequest.namespaces) {
            for (dataElementName in documentRequest.getEntryNames(namespaceName!!)) {
                val intentToRetain =
                    documentRequest.getIntentToRetain(namespaceName, dataElementName!!)
                elements.add(DataElement(namespaceName, dataElementName, intentToRetain, false))
            }
        }
        return DocumentRequest(elements)
    }

    private fun issuerSignedItemClearValue(encodedIssuerSignedItem: ByteArray): ByteArray {
        val encodedNullValue = Cbor.encode(Simple.NULL)
        return issuerSignedItemSetValue(encodedIssuerSignedItem, encodedNullValue)
    }

    private fun issuerSignedItemSetValue(
        encodedIssuerSignedItem: ByteArray,
        encodedElementValue: ByteArray
    ): ByteArray {
        val map = Cbor.decode(encodedIssuerSignedItem)
        val builder = CborMap.builder()
        for (key in map.asMap.keys) {
            if (key.asTstr == "elementValue") {
                builder.put(key, RawCbor(encodedElementValue))
            } else {
                builder.put(key, map[key])
            }
        }
        return Cbor.encode(builder.end().build())
    }

    /**
     * Generates a self-signed IACA certificate according to ISO/IEC 18013-5:2021 Annex B.1.2.
     *
     * @param iacaKey the private key.
     * @param subject the value to use for subject and issuer, e.g. "CN=Test IACA,C=ZZ".
     * @param serial the serial number to use for the certificate.
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @param issuerAltNameUrl the issuer alternative name (see RFC 5280 section 4.2.1.7),
     * e.g. "http://issuer.example.com/informative/web/page".
     * @param crlUrl the URL for revocation (see RFC 5280 section 4.2.1.13).
     * @return a [X509Cert] with all the required extensions.
     */
    fun generateIacaCertificate(
        iacaKey: EcPrivateKey,
        subject: X500Name,
        serial: ASN1Integer,
        validFrom: Instant,
        validUntil: Instant,
        issuerAltNameUrl: String,
        crlUrl: String
    ): X509Cert {
        return X509Cert.Builder(
            publicKey = iacaKey.publicKey,
            signingKey = iacaKey,
            signatureAlgorithm = iacaKey.curve.defaultSigningAlgorithm,
            serialNumber = serial,
            subject = subject,
            issuer = subject,
            validFrom = validFrom,
            validUntil = validUntil
        )
            .includeSubjectKeyIdentifier()
            // From 18013-5 table B.1: critical: Key certificate signature + CRL signature bits set
            .setKeyUsage(setOf(X509KeyUsage.CRL_SIGN, X509KeyUsage.KEY_CERT_SIGN))
            // From 18013-5 table B.1: critical, CA=true, pathLenConstraint=0
            .setBasicConstraints(true, 0)
            // From 18013-5 table B.1: non-critical, Email or URL
            .addExtension(
                OID.X509_EXTENSION_ISSUER_ALT_NAME.oid,
                false,
                ASN1.encode(
                    ASN1Sequence(listOf(
                        ASN1TaggedObject(
                            ASN1TagClass.CONTEXT_SPECIFIC,
                            ASN1Encoding.PRIMITIVE,
                            6,
                            issuerAltNameUrl.encodeToByteArray()
                        )
                    ))
                )
            )
            // From 18013-5 table B.1: non-critical, The ‘reasons’ and ‘cRL Issuer’
            // fields shall not be used.
            .addExtension(
                OID.X509_EXTENSION_CRL_DISTRIBUTION_POINTS.oid,
                false,
                ASN1.encode(
                    ASN1Sequence(listOf(
                        ASN1Sequence(listOf(
                            ASN1TaggedObject(ASN1TagClass.CONTEXT_SPECIFIC, ASN1Encoding.CONSTRUCTED, 0, ASN1.encode(
                                ASN1TaggedObject(ASN1TagClass.CONTEXT_SPECIFIC, ASN1Encoding.CONSTRUCTED, 0, ASN1.encode(
                                    ASN1TaggedObject(ASN1TagClass.CONTEXT_SPECIFIC, ASN1Encoding.PRIMITIVE, 6,
                                        crlUrl.encodeToByteArray()
                                    )
                                ))
                            ))
                        ))
                    ))
                )
            )
            .build()
    }

    /**
     * Generates a Document Signing certificate according to ISO/IEC 18013-5:2021 Annex B.1.4.
     *
     * @param iacaCert the IACA certificate.
     * @param iacaKey the private key for the IACA certificate.
     * @param dsKey the public part of the DS key.
     * @param subject the value to use for subject, e.g. "CN=Test DS,C=ZZ".
     * @param serial the serial number to use for the certificate.
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @return a [X509Cert] with all the required extensions.
     */
    fun generateDsCertificate(
        iacaCert: X509Cert,
        iacaKey: EcPrivateKey,
        dsKey: EcPublicKey,
        subject: X500Name,
        serial: ASN1Integer,
        validFrom: Instant,
        validUntil: Instant,
    ): X509Cert {
        return X509Cert.Builder(
            publicKey = dsKey,
            signingKey = iacaKey,
            signatureAlgorithm = iacaKey.curve.defaultSigningAlgorithm,
            serialNumber = serial,
            subject = subject,
            issuer = iacaCert.subject,
            validFrom = validFrom,
            validUntil = validUntil
        )
            .includeSubjectKeyIdentifier()
            .setAuthorityKeyIdentifierToCertificate(iacaCert)
            // From 18013-5 table B.3: critical: Key certificate signature + CRL signature bits set
            .setKeyUsage(setOf(X509KeyUsage.DIGITAL_SIGNATURE))
            // From 18013-5 table B.3: non-critical, Extended Key usage
            .addExtension(
                OID.X509_EXTENSION_EXTENDED_KEY_USAGE.oid,
                true,
                ASN1.encode(ASN1Sequence(listOf(
                    ASN1ObjectIdentifier(OID.ISO_18013_5_MDL_DS.oid)
                )))
            )
            // From 18013-5 table B.3: non-critical, Email or URL
            .addExtension(
                OID.X509_EXTENSION_ISSUER_ALT_NAME.oid,
                false,
                iacaCert.getExtensionValue(OID.X509_EXTENSION_ISSUER_ALT_NAME.oid)!!
            )
            // From 18013-5 table B.3: non-critical, The ‘reasons’ and ‘cRL Issuer’
            // fields shall not be used.
            .addExtension(
                OID.X509_EXTENSION_CRL_DISTRIBUTION_POINTS.oid,
                false,
                iacaCert.getExtensionValue(OID.X509_EXTENSION_CRL_DISTRIBUTION_POINTS.oid)!!
            )
            .build()
    }

    /**
     * Generates a self-signed reader root certificate.
     *
     * Note that there are no requirements in ISO/IEC 18013-5:2021 for reader certificates.
     *
     * @param readerRootKey the private key.
     * @param subject the value to use for subject and issuer, e.g. "CN=Test Reader Root,C=ZZ".
     * @param serial the serial number to use for the certificate.
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @return a [X509Cert].
     */
    fun generateReaderRootCertificate(
        readerRootKey: EcPrivateKey,
        subject: X500Name,
        serial: ASN1Integer,
        validFrom: Instant,
        validUntil: Instant,
    ): X509Cert {
        return X509Cert.Builder(
            publicKey = readerRootKey.publicKey,
            signingKey = readerRootKey,
            signatureAlgorithm = readerRootKey.curve.defaultSigningAlgorithm,
            serialNumber = serial,
            subject = subject,
            issuer = subject,
            validFrom = validFrom,
            validUntil = validUntil
        )
            .includeSubjectKeyIdentifier()
            .setKeyUsage(setOf(X509KeyUsage.CRL_SIGN, X509KeyUsage.KEY_CERT_SIGN))
            .setBasicConstraints(true, 0)
            .build()
    }

    /**
     * Generates a reader certificate.
     *
     * Note that there are no requirements in ISO/IEC 18013-5:2021 for reader certificates.
     *
     * @param readerRootCert the reader root certificate.
     * @param readerRootKey the private key for the reader root certificate.
     * @param readerKey the public part of the reader key.
     * @param subject the value to use for subject, e.g. "CN=Test Reader,C=ZZ".
     * @param serial the serial number to use for the certificate.
     * @param validFrom the point in time the certificate should be valid from.
     * @param validUntil the point in time the certificate should be valid until.
     * @return a [X509Cert] with all the required extensions.
     */
    fun generateReaderCertificate(
        readerRootCert: X509Cert,
        readerRootKey: EcPrivateKey,
        readerKey: EcPublicKey,
        subject: X500Name,
        serial: ASN1Integer,
        validFrom: Instant,
        validUntil: Instant,
    ): X509Cert {
        return X509Cert.Builder(
            publicKey = readerKey,
            signingKey = readerRootKey,
            signatureAlgorithm = readerRootKey.curve.defaultSigningAlgorithm,
            serialNumber = serial,
            subject = subject,
            issuer = readerRootCert.subject,
            validFrom = validFrom,
            validUntil = validUntil
        )
            .includeSubjectKeyIdentifier()
            .setAuthorityKeyIdentifierToCertificate(readerRootCert)
            .setKeyUsage(setOf(X509KeyUsage.DIGITAL_SIGNATURE))
            .build()
    }

    /**
     * Helper function to generate a list of claims for an mdoc.
     *
     * @param docType the mdoc document type.
     * @param requestedData a map from namespace into a list of data elements where each
     *     pair is the data element name and whether the data element will be retained.
     * @param documentTypeRepository a [DocumentTypeRepository] used to determine the display name for claims.
     * @param mdocCredential if set, the returned list is filtered so it only references data
     *     elements available in the credential.
     */
    fun generateRequestedClaims(
        docType: String,
        requestedData: Map<String, List<Pair<String, Boolean>>>,
        documentTypeRepository: DocumentTypeRepository,
        mdocCredential: MdocCredential?,
    ): List<MdocRequestedClaim> {
        val mdocDocumentType = documentTypeRepository.getDocumentTypeForMdoc(docType)?.mdocDocumentType
        val ret = mutableListOf<MdocRequestedClaim>()
        for ((namespaceName, listOfDe) in requestedData) {
            for ((dataElementName, intentToRetain) in listOfDe) {
                val attribute =
                    mdocDocumentType?.namespaces
                        ?.get(namespaceName)
                        ?.dataElements
                        ?.get(dataElementName)
                        ?.attribute
                ret.add(
                    MdocRequestedClaim(
                        displayName = attribute?.displayName ?: dataElementName,
                        attribute = attribute,
                        namespaceName = namespaceName,
                        dataElementName = dataElementName,
                        intentToRetain = intentToRetain,
                    )
                )
            }
        }
        return filterConsentFields(ret, mdocCredential)
    }
}

/**
 * Convert to a [MdocRequest].
 *
 * @param documentTypeRepository a [DocumentTypeRepository] used to determine the display name for claims.
 * @param mdocCredential if set, the returned list is filtered so it only references data
 *     elements available in the credential.
 * @param requesterAppId the appId if an app is making the request or `null`.
 * @param requesterWebsiteOrigin the website origin if a website is making the request or `null`.
 */
fun DeviceRequestParser.DocRequest.toMdocRequest(
    documentTypeRepository: DocumentTypeRepository,
    mdocCredential: MdocCredential?,
    requesterAppId: String? = null,
    requesterWebsiteOrigin: String? = null,
): MdocRequest {
    val requestedData = mutableMapOf<String, MutableList<Pair<String, Boolean>>>()
    for (namespaceName in namespaces) {
        for (dataElementName in getEntryNames(namespaceName)) {
            val intentToRetain = getIntentToRetain(namespaceName, dataElementName)
            requestedData.getOrPut(namespaceName) { mutableListOf() }
                .add(Pair(dataElementName, intentToRetain))
        }
    }
    return MdocRequest(
        requester = Requester(
            certChain = if (readerAuthenticated) {
                readerCertificateChain
            } else {
                null
            },
            appId = requesterAppId,
            websiteOrigin = requesterWebsiteOrigin
        ),
        requestedClaims = MdocUtil.generateRequestedClaims(
            docType,
            requestedData,
            documentTypeRepository,
            mdocCredential
        ),
        docType = docType
    )
}

private fun calcAvailableDataElements(
    issuerNameSpaces: Map<String, List<ByteArray>>
): Map<String, Set<String>> {
    val ret = mutableMapOf<String, Set<String>>()
    for (nameSpaceName in issuerNameSpaces.keys) {
        val innerSet = mutableSetOf<String>()
        for (encodedIssuerSignedItemBytes in issuerNameSpaces[nameSpaceName]!!) {
            val issuerSignedItem = Cbor.decode(encodedIssuerSignedItemBytes).asTaggedEncodedCbor
            val elementIdentifier = issuerSignedItem["elementIdentifier"].asTstr
            innerSet.add(elementIdentifier)
        }
        ret[nameSpaceName] = innerSet
    }
    return ret
}

private fun filterConsentFields(
    list: List<MdocRequestedClaim>,
    credential: MdocCredential?
): List<MdocRequestedClaim> {
    if (credential == null) {
        return list
    }
    val staticAuthData = StaticAuthDataParser(credential.issuerProvidedData).parse()
    val availableDataElements = calcAvailableDataElements(staticAuthData.digestIdMapping)
    return list.filter { mdocConsentField ->
        availableDataElements[mdocConsentField.namespaceName]
            ?.contains(mdocConsentField.dataElementName) != null
    }
}

